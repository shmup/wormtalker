const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{
        .default_target = .{
            .cpu_arch = .x86_64,
            .os_tag = .windows,
            .abi = .gnu,
        },
    });
    const optimize = b.standardOptimizeOption(.{});

    // generate sound_banks.zig at configure time (writes to src/)
    generateSoundBanksFile(b.allocator) catch @panic("failed to generate sound banks");

    const exe = b.addExecutable(.{
        .name = "wormboard",
        .root_module = b.createModule(.{
            .root_source_file = b.path("src/main.zig"),
            .target = target,
            .optimize = optimize,
        }),
    });

    // link windows libs
    exe.linkSystemLibrary("gdi32");
    exe.linkSystemLibrary("user32");
    exe.linkSystemLibrary("winmm");

    b.installArtifact(exe);

    const run_cmd = b.addRunArtifact(exe);
    run_cmd.step.dependOn(b.getInstallStep());
    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    const run_step = b.step("run", "run wormboard");
    run_step.dependOn(&run_cmd.step);
}

fn generateSoundBanksFile(allocator: std.mem.Allocator) !void {
    var output: std.ArrayListUnmanaged(u8) = .empty;
    const writer = output.writer(allocator);

    // scan Speech-Banks directory
    const banks_path = "src/wavs/Speech-Banks";
    var banks_dir = std.fs.cwd().openDir(banks_path, .{ .iterate = true }) catch |err| {
        std.debug.print("failed to open {s}: {}\n", .{ banks_path, err });
        return error.FailedToOpenDir;
    };
    defer banks_dir.close();

    var banks: std.ArrayListUnmanaged(BankInfo) = .empty;
    defer banks.deinit(allocator);

    var dir_iter = banks_dir.iterate();
    while (try dir_iter.next()) |entry| {
        if (entry.kind == .directory) {
            var wavs: std.ArrayListUnmanaged([]const u8) = .empty;

            var bank_dir = banks_dir.openDir(entry.name, .{ .iterate = true }) catch continue;
            defer bank_dir.close();

            var wav_iter = bank_dir.iterate();
            while (try wav_iter.next()) |wav_entry| {
                if (wav_entry.kind == .file) {
                    const name = wav_entry.name;
                    if (std.mem.endsWith(u8, name, ".WAV") or std.mem.endsWith(u8, name, ".wav")) {
                        try wavs.append(allocator, try allocator.dupe(u8, name));
                    }
                }
            }

            std.mem.sort([]const u8, wavs.items, {}, struct {
                fn lessThan(_: void, lhs: []const u8, rhs: []const u8) bool {
                    return std.mem.lessThan(u8, lhs, rhs);
                }
            }.lessThan);

            if (wavs.items.len > 0) {
                try banks.append(allocator, .{
                    .name = try allocator.dupe(u8, entry.name),
                    .wavs = try wavs.toOwnedSlice(allocator),
                });
            }
        }
    }

    std.mem.sort(BankInfo, banks.items, {}, struct {
        fn lessThan(_: void, lhs: BankInfo, rhs: BankInfo) bool {
            return std.mem.lessThan(u8, lhs.name, rhs.name);
        }
    }.lessThan);

    // write header
    try writer.writeAll(
        \\// auto-generated by build.zig - do not edit
        \\
        \\pub const WavFile = struct {
        \\    name: []const u8,
        \\    data: []const u8,
        \\};
        \\
        \\pub const SoundBank = struct {
        \\    name: [:0]const u8,
        \\    wavs: []const WavFile,
        \\};
        \\
        \\
    );

    // generate each bank's wav array
    for (banks.items) |bank| {
        var ident_buf: [128]u8 = undefined;
        const ident = sanitizeIdent(bank.name, &ident_buf);

        try writer.print("const {s}_wavs = [_]WavFile{{\n", .{ident});
        for (bank.wavs) |wav| {
            var base_buf: [128]u8 = undefined;
            const base = wavBaseName(wav, &base_buf);
            try writer.print("    .{{ .name = \"{s}\", .data = @embedFile(\"wavs/Speech-Banks/{s}/{s}\") }},\n", .{ base, bank.name, wav });
        }
        try writer.writeAll("};\n\n");
    }

    // generate the banks array
    try writer.writeAll("pub const sound_banks = [_]SoundBank{\n");
    for (banks.items) |bank| {
        var ident_buf: [128]u8 = undefined;
        const ident = sanitizeIdent(bank.name, &ident_buf);
        try writer.print("    .{{ .name = \"{s}\", .wavs = &{s}_wavs }},\n", .{ bank.name, ident });
    }
    try writer.writeAll("};\n");

    // write to src/sound_banks.zig
    const file = try std.fs.cwd().createFile("src/sound_banks.zig", .{});
    defer file.close();
    try file.writeAll(try output.toOwnedSlice(allocator));
}

const BankInfo = struct {
    name: []const u8,
    wavs: []const []const u8,
};

fn sanitizeIdent(name: []const u8, buf: []u8) []const u8 {
    var i: usize = 0;
    for (name) |c| {
        if (i >= buf.len - 1) break;
        if (std.ascii.isAlphanumeric(c)) {
            buf[i] = std.ascii.toLower(c);
            i += 1;
        } else if (c == ' ' or c == '-' or c == '_') {
            buf[i] = '_';
            i += 1;
        }
    }
    return buf[0..i];
}

fn wavBaseName(filename: []const u8, buf: []u8) []const u8 {
    const name = if (std.mem.endsWith(u8, filename, ".WAV") or std.mem.endsWith(u8, filename, ".wav"))
        filename[0 .. filename.len - 4]
    else
        filename;
    // lowercase the name
    for (name, 0..) |c, i| {
        if (i >= buf.len) break;
        buf[i] = std.ascii.toLower(c);
    }
    return buf[0..@min(name.len, buf.len)];
}
